GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-05-19 15:41:33.6193798
>>> 23+5
28
2022-05-19 15:54:14.3086541
>>> >>>3+2*5

<interactive>:2:1: error: parse error on input ‘>>>’
2022-05-19 15:55:48.5688258
>>> 3+2*5
13
2022-05-19 15:56:23.4815413
>>> (3+2)*5
25
2022-05-19 15:56:52.5679748
>>> 5-4-8
-7
2022-05-19 15:57:02.4829634
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:33.0639998
>>> double 3

<interactive>:7:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:03.6035972
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-05-26 15:02:14.5947464
>>> maxBound::Int
9223372036854775807
2022-05-26 15:03:35.9265436
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:04:12.0650648
>>> 2 ^63-1
9223372036854775807
2022-05-26 15:05:03.0406824
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:37.021068
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:21:01.8908595
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:24:09.5020991
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-05-26 15:49:03.6792626
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:03.7499888
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + y
   5  
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:4:16: error: Variable not in scope: y :: Int
  |
4 | double x = x + y
  |                ^
Failed, no modules loaded.
2022-05-26 15:52:57.5954696
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:4:16: error: Variable not in scope: y :: Int
  |
4 | double x = x + y
  |                ^
Failed, no modules loaded.
2022-05-26 15:52:57.6906069
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + X
   5  
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:4:16: error: Data constructor not in scope: X :: Int
  |
4 | double x = x + X
  |                ^
Failed, no modules loaded.
2022-05-26 15:53:50.3325361
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:4:16: error: Data constructor not in scope: X :: Int
  |
4 | double x = x + X
  |                ^
Failed, no modules loaded.
2022-05-26 15:53:50.4296642
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:55:55.3087685
>>> double 3
6
2022-05-26 15:56:32.7027622
>>> double 6
12
2022-05-26 15:56:47.009364
>>> double 8
16
2022-05-26 15:56:56.4319263
>>> doublr (1+2)

<interactive>:17:1: error:
    • Variable not in scope: doublr :: t0 -> t
    • Perhaps you meant ‘double’ (line 4)
2022-05-26 15:57:29.0722129
>>> doublr (1 + 2)

<interactive>:18:1: error:
    • Variable not in scope: doublr :: t0 -> t
    • Perhaps you meant ‘double’ (line 4)
2022-05-26 15:57:55.7456353
>>> double (1+2)
6
2022-05-26 15:58:23.9807144
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-06-09 14:54:57.5116019
>>> 2+3*4
14
2022-06-09 14:57:51.4736143
>>> (2+3)*4
20
2022-06-09 14:59:58.7658451
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:01:15.6913763
>>> sqrt (3^2+4^2)
5.0
2022-06-09 15:03:17.1402537
>>> sqrt (25::Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:10.9950863
>>> sqrt (25::Double)
5.0
2022-06-09 15:09:41.0182136
>>> hoge 225::Int

<interactive>:7:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:32.882701
>>> hoge 25::Int

<interactive>:8:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:15:26.9127739
>>> head[1,2,3]
1
2022-06-09 15:46:40.3059894
>>> head[3,1,4,1,5]
3
2022-06-09 15:47:12.3401175
>>> head[]
*** Exception: Prelude.head: empty list
2022-06-09 15:48:30.9429812
>>> hoge=[3,1,4,1,5]::[Int]
2022-06-09 15:50:55.4268071
>>> hoge
[3,1,4,1,5]
2022-06-09 15:51:12.1116685
>>> head hoge
3
2022-06-09 15:51:35.4386875
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:52.7947622
>>> tail[]
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:33.8263275
>>> hoge!!0
3
2022-06-09 15:55:10.0420972
>>> hoge 2 !! 

<interactive>:18:11: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 15:56:18.1331267
>>> hoge!!2
4
2022-06-09 15:56:57.1262122
>>> take 3 hoge
[3,1,4]
2022-06-09 15:57:21.1467806
>>> hogee

<interactive>:21:1: error:
    • Variable not in scope: hogee
    • Perhaps you meant ‘hoge’ (line 12)
2022-06-09 15:57:30.9367187
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:37.2759776
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:56.9064427
>>> hoge 5 hoge

<interactive>:24:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:24:1)
2022-06-09 15:58:30.2758631
>>> hoge!!5
*** Exception: Prelude.!!: index too large
2022-06-09 15:59:01.8389564
>>> take10

<interactive>:26:1: error:
    • Variable not in scope: take10
    • Perhaps you meant ‘take’ (imported from Prelude)
2022-06-09 15:59:13.5451604
>>> take10 hoge

<interactive>:27:1: error:
    • Variable not in scope: take10 :: [Int] -> t
    • Perhaps you meant ‘take’ (imported from Prelude)
2022-06-09 15:59:36.1550579
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:58.2634217
>>> drop 10 hoge
[]
2022-06-09 16:00:11.5434313
>>> length head

<interactive>:30:1: error:
    • No instance for (Foldable ((->) [a0]))
        arising from a use of ‘length’
    • In the expression: length head
      In an equation for ‘it’: it = length head
2022-06-09 16:01:00.6170418
>>> length hoge
5
2022-06-09 16:01:20.293513
>>> length []
0
2022-06-09 16:01:37.7646558
>>> sum hoge
14
2022-06-09 16:02:04.9018467
>>> product hoge
60
2022-06-09 16:03:05.1798592
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:46.8220115
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:40.6689754
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-06-09 16:07:55.8588345
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:07:55.9188157
>>> double 3+3
9
2022-06-09 16:08:28.9029522
>>> doule (3+3)

<interactive>:40:1: error:
    • Variable not in scope: doule :: t0 -> t
    • Perhaps you meant ‘double’ (line 4)
2022-06-09 16:11:34.7810421
>>> double (3 + 3)
12
2022-06-09 16:12:08.8373235
>>> :guit
unknown command ':guit'
use :? for help.
2022-06-09 16:20:07.0590725
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-06-16 15:03:32.8783836
>>> take 3 [3,1,1,5]
[3,1,1]
2022-06-16 15:04:28.1304951
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:05:01.6213442
>>> :e src/Firs.hs
catn: src/Firs.hs: openFile: does not exist (No such file or directory)
2022-06-16 15:10:47.3669507
>>> :l src/Firs.hs

<no location info>: error: can't find file: src/Firs.hs
Failed, no modules loaded.
2022-06-16 15:10:47.4385084
>>> double

<interactive>:5:1: error: Variable not in scope: double
2022-06-16 15:12:55.042216
>>> take (double 2)

<interactive>:6:7: error:
    Variable not in scope: double :: t0 -> Int
2022-06-16 15:15:08.5210405
>>> src/First.hs

<interactive>:7:5: error:
    Not in scope: ‘First.hs’
    No module named ‘First’ is imported.
2022-06-16 15:16:37.5604044
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)

<no location info>: error: can't find file: src/Firs.hs
Failed, no modules loaded.
2022-06-16 15:17:41.9577322
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:17:42.041657
>>> double

<interactive>:10:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:18:35.8323921
>>> taek (double 2)

<interactive>:11:1: error:
    • Variable not in scope: taek :: Int -> t
    • Perhaps you meant ‘take’ (imported from Prelude)
2022-06-16 15:19:12.5208534
>>> take(double2)

<interactive>:12:6: error:
    • Variable not in scope: double2 :: Int
    • Perhaps you meant ‘double’ (line 4)
2022-06-16 15:19:57.2265141
>>> take (double 2 )

<interactive>:13:1: error:
    • No instance for (Show ([a0] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:20:09.0575643
>>> take (doule 2) [1,2,3,4,5]

<interactive>:14:7: error:
    • Variable not in scope: doule :: t0 -> Int
    • Perhaps you meant ‘double’ (line 4)
2022-06-16 15:21:14.7553387
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:21:41.3643358
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n=probuct[1..n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:12: error:
    • Variable not in scope: probuct :: [Integer] -> Integer
    • Perhaps you meant ‘product’ (imported from Prelude)
   |
10 | factrial n=probuct[1..n]
   |            ^^^^^^^
Failed, no modules loaded.
2022-06-16 15:24:03.9513811
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:25:52.2302792
>>> factrial 3
6
2022-06-16 15:26:25.5097215
>>> factrial 4
24
2022-06-16 15:26:43.2289538
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int -> Int
  16  ave xs = div (sum xs)(length xs)
  17  
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:16:10: error:
    • Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’
    • Possible cause: ‘div’ is applied to too many arguments
      In the expression: div (sum xs) (length xs)
      In an equation for ‘ave’: ave xs = div (sum xs) (length xs)
   |
16 | ave xs = div (sum xs)(length xs)
   |          ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:38:08.001953
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:16:10: error:
    • Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’
    • Possible cause: ‘div’ is applied to too many arguments
      In the expression: div (sum xs) (length xs)
      In an equation for ‘ave’: ave xs = div (sum xs) (length xs)
   |
16 | ave xs = div (sum xs) (length xs)
   |          ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:38:43.3197788
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:40:50.5151559
>>> average[1,2,3,4,5]
3
2022-06-16 15:45:12.5745152
>>> 
2022-06-16 15:49:38.5390257
>>> t take 3[1,2,3,4,5]

<interactive>:25:1: error:
    Variable not in scope:
      t :: (Int -> [a0] -> [a0]) -> t0 -> [a1] -> t
2022-06-16 15:50:06.0264892
>>> t take 3 [1,2,3,4,5]

<interactive>:26:1: error:
    Variable not in scope:
      t :: (Int -> [a0] -> [a0]) -> t0 -> [a1] -> t
2022-06-16 15:50:35.3955312
>>> 
2022-06-16 16:06:49.0076787
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:11.6409429
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x[]) = []
  20  myinit (x:xs)  = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:19:9: error: Parse error in pattern: x
   |
19 | myinit (x[]) = []
   |         ^^^
Failed, no modules loaded.
2022-06-16 16:14:29.0464499
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs)  = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:15:22.3977581
>>> myinit [1..5]
[1,2,3,4]
2022-06-16 16:15:49.1656729
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,30): Non-exhaustive patterns in function myinit

2022-06-16 16:16:10.6489554
>>> :t take 3[1,2,3,4,5]
take 3[1,2,3,4,5] :: Num a => [a]
2022-06-16 16:19:01.511632
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-06-23 14:56:12.4774208
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:30.0324556
>>> 1==2
False
2022-06-23 15:06:12.2948898
>>> 1<2
True
2022-06-23 15:06:27.8606675
>>> 1<=2
True
2022-06-23 15:06:38.6427906
>>> 1>=2
False
2022-06-23 15:06:51.9093308
>>> 'a'<'b'
True
2022-06-23 15:11:27.6548025
>>> 'a'<'B'
False
2022-06-23 15:11:41.7636986
>>> ''<'a'

<interactive>:8:1: error:
    Parser error on `''`
    Character literals may not be empty
2022-06-23 15:12:09.7948113
>>> 'ab'<'b'

<interactive>:9:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:13:01.8673027
>>> 1/=2
True
2022-06-23 15:15:56.6981361
>>> 1/=1
False
2022-06-23 15:16:05.7441391
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:26.1211459
>>> abu

<interactive>:13:1: error:
    • Variable not in scope: abu
    • Perhaps you meant ‘abs’ (imported from Prelude)
2022-06-23 15:30:47.7963126
>>> abu (-234)

<interactive>:14:1: error:
    • Variable not in scope: abu :: t0 -> t
    • Perhaps you meant ‘abs’ (imported from Prelude)
2022-06-23 15:34:52.2803975
>>> abs (-234)
234
2022-06-23 15:35:14.7372551
>>> 
2022-06-23 15:42:15.7770094
>>> 
2022-06-23 15:43:14.8234113
>>> 
2022-06-23 15:55:04.1042079
>>> 
2022-06-23 15:56:25.4824324
>>> 
2022-06-23 15:56:26.9438724
>>> 
2022-06-23 15:56:27.3929506
>>> 
2022-06-23 15:56:27.8820427
>>> 
2022-06-23 15:56:28.3689953
>>> 
2022-06-23 15:56:28.9218263
>>> 
2022-06-23 15:56:29.3783986
>>> 
2022-06-23 15:56:29.8743396
>>> 
2022-06-23 15:56:30.4030275
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-06-30 14:58:32.8416314
>>> [ x ^ 2 | x <-[1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:01:52.1362432
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:05:02.1939087
>>> [ x ^*2 | x <-[1 .. 5] ]

<interactive>:3:5: error:
    • Variable not in scope: (^*) :: t0 -> t1 -> a
    • Perhaps you meant one of these:
        ‘*’ (imported from Prelude), ‘^’ (imported from Prelude),
        ‘<*’ (imported from Prelude)
2022-06-30 15:11:49.6141761
>>> [ x *2 | x <-[1 .. 5] ]
[2,4,6,8,10]
2022-06-30 15:12:34.0417733
>>> [x 'div' 2 | x < [1..5]]

<interactive>:5:4: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:13:54.2572419
>>> [ x 'div' 2 | x <-1..5]]

<interactive>:6:20: error: parse error on input ‘..’
2022-06-30 15:15:23.7582334
>>> [ x 'diModv' 2| x <=[1 .. 5]]

<interactive>:7:5: error:
    • Syntax error on 'diModv'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'diModv'
2022-06-30 15:20:26.3823097
>>> [ x 'div' 2| x <=[1 .. 5]]

<interactive>:8:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:21:18.0546169
>>> [(x,y) | y<-[4,5],x<- "abc"]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:25:40.8879859
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs)  = x : (init xs)
  21  
  22  myconcat :: [[a]]->[a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
Ok, no modules loaded.
2022-06-30 15:30:14.8890575
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:30:14.9132806
>>> myconcat [[1,2,3],[4,5],[6,7,8]

<interactive>:12:32: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-30 15:47:36.8389025
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-06-30 15:47:58.8716543
>>> [ 1 |_<- [1..5]]
[1,1,1,1,1]
2022-06-30 15:49:32.4911628
>>> l src/First.hs

<interactive>:15:7: error: Not in scope: ‘First.hs’
2022-06-30 15:51:56.8076155
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs)  = x : (init xs)
  21  
  22  myconcat :: [[a]]->[a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
  24  
  25  mylengty :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:25:1: error:
    The type signature for ‘mylengty’ lacks an accompanying binding
      Perhaps you meant ‘mylength’ (Defined at src/First.hs:26:1)
   |
25 | mylengty :: [a] -> Int
   | ^^^^^^^^
Failed, no modules loaded.
2022-06-30 15:53:02.6547003
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:25:1: error:
    The type signature for ‘mylengty’ lacks an accompanying binding
      Perhaps you meant ‘mylength’ (Defined at src/First.hs:26:1)
   |
25 | mylengty :: [a] -> Int
   | ^^^^^^^^
Failed, no modules loaded.
2022-06-30 15:53:02.7664663
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs)  = x : (init xs)
  21  
  22  myconcat :: [[a]]->[a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:53:26.552102
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:53:26.6739759
>>> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:53:53.072889
>>> ['あ'..'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:54:34.8507117
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:54:59.9909642
>>> [ x 'div' 2| x <-[1 .. 5]]

<interactive>:23:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:55:26.4567793
>>> [(x,y) | "abc",y<-[4,5]]

<interactive>:24:3: error: Variable not in scope: x
2022-06-30 15:56:28.3114867
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-07-07 09:17:04.0182329
>>> [ x ^ 2 |  x <-[1 .. 5] ]
[1,4,9,16,25]
2022-07-07 09:19:20.7304677
>>> map (^2) [1 .. 5]]

<interactive>:2:18: error: parse error on input ‘]’
2022-07-07 09:19:53.6650425
>>> map (2^) [1..5]
[2,4,8,16,32]
2022-07-07 09:20:28.9362784
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-07-07 09:20:54.9759391
>>> [ x `div` 2 | x < [1..5]]

<interactive>:5:3: error: Variable not in scope: x

<interactive>:5:15: error: Variable not in scope: x :: [a0]
2022-07-07 09:23:24.7221609
>>> [ x `div` 2 | x <- [1..5]]
[0,1,1,2,2]
2022-07-07 09:24:03.8409234
>>> [ x `divmod` 2 | x <- [1..5]]

<interactive>:7:5: error:
    • Variable not in scope: divmod :: t0 -> t1 -> a
    • Perhaps you meant ‘divMod’ (imported from Prelude)
2022-07-07 09:27:02.1023284
>>> [ x `divmod` 2 | x <- [1 .. 5]]

<interactive>:8:5: error:
    • Variable not in scope: divmod :: t0 -> t1 -> a
    • Perhaps you meant ‘divMod’ (imported from Prelude)
2022-07-07 09:28:12.1183955
>>> [x `divmod` 2|x <-[1 .. 5]]

<interactive>:9:4: error:
    • Variable not in scope: divmod :: t0 -> t1 -> a
    • Perhaps you meant ‘divMod’ (imported from Prelude)
2022-07-07 09:29:17.1241719
>>> [(x,y) | x <- "abc",y<- [4,5]]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-07-07 09:33:11.3978966
>>> [(x,y) | y <- [4,5], x <- "abc"]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-07-07 09:35:15.6343428
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:12:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-07-07 09:37:10.3445208
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:13:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-07-07 09:38:18.7178204
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-07-07 16:04:59.7200777
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:05:31.129163
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:05:31.2054027
>>> ord 'A'
65
2022-07-07 16:05:52.3588388
>>> ord'a'

<interactive>:4:1: error: Variable not in scope: ord'a'
2022-07-07 16:06:07.4120009
>>> ord 'a'
97
2022-07-07 16:06:29.1212361
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-07-07 16:19:37.6155232
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x =double (double x)
   8  
   9  factrial::Integer -> Integer
  10  factrial n = product [1..n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs)  = x : (init xs)
  21  
  22  myconcat :: [[a]]->[a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs]
Ok, no modules loaded.
2022-07-07 16:20:10.1357219
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:20:10.3971273
>>> [x `divMod` 2|x<-[1..5]]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-07-07 16:21:16.4062264
>>> myconcat[[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-07-07 16:21:48.7946228
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/saya/bprog2022/.ghci
2022-07-14 15:11:24.7451645
>>> :e src/Caedar.hs
catn: src/Caedar.hs: openFile: does not exist (No such file or directory)
2022-07-14 15:12:20.272324
>>> :l src/Caedar.hs

<no location info>: error: can't find file: src/Caedar.hs
Failed, no modules loaded.
2022-07-14 15:12:20.3399391
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int c = ord c

<no location info>: error: can't find file: src/Caedar.hs
Failed, no modules loaded.
2022-07-14 15:12:49.3231821
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:12:49.4189717
>>> let2int 'a'
97
2022-07-14 15:13:25.2796219
>>> let2int 'z'
122
2022-07-14 15:13:46.8328956
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int c = ord a
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:17: error: Variable not in scope: a :: Char
  |
6 | let2int c = ord a
  |                 ^
Failed, no modules loaded.
2022-07-14 15:15:09.45127
>>> let2int 'a'

<interactive>:8:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 15:15:35.8113837
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int c = ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:16:00.1355679
>>> let2int 'a'
97
2022-07-14 15:16:06.7496935
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ort 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:22: error:
    • Variable not in scope: ort :: Char -> Int
    • Perhaps you meant one of these:
        ‘ord’ (imported from Data.Char), ‘or’ (imported from Prelude)
  |
6 | let2int  c = ord c - ort 'a'
  |                      ^^^
Failed, no modules loaded.
2022-07-14 15:16:56.8877413
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:17:12.1669228
>>> let2int 'a'
0
2022-07-14 15:17:18.2797332
>>> let2int 'z'
25
2022-07-14 15:17:28.6654307
>>> ord 'a'
97
2022-07-14 15:19:23.4751599
>>> chr 97
'a'
2022-07-14 15:19:35.4264029
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:18.5873103
>>> int2let 0
'a'
2022-07-14 15:20:32.9188669
>>> int2let 25
'z'
2022-07-14 15:20:55.1010519
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:14:15: error:
    parse error (possibly incorrect indentation or mismatched brackets)
   |
14 |     |otherwise
   |               ^
Failed, no modules loaded.
2022-07-14 15:27:41.1974741
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:9:28: error: Variable not in scope: n :: Int
  |
9 | int2let i = chr (ord 'a' + n)
  |                            ^
Failed, no modules loaded.
2022-07-14 15:27:57.7347034
>>> shuft (-3) 'd'

<interactive>:22:1: error:
    Variable not in scope: shuft :: t0 -> Char -> t
2022-07-14 15:29:02.6759219
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:9:28: error: Variable not in scope: n :: Int
  |
9 | int2let i = chr (ord 'a' + n)
  |                            ^
Failed, no modules loaded.
2022-07-14 15:29:15.6941345
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:29:39.276945
>>> shuft (-3) 'd'

<interactive>:25:1: error:
    • Variable not in scope: shuft :: t0 -> Char -> t
    • Perhaps you meant ‘shift’ (line 12)
2022-07-14 15:29:44.5733086
>>> shuft 3 'a'

<interactive>:26:1: error:
    • Variable not in scope: shuft :: t0 -> Char -> t
    • Perhaps you meant ‘shift’ (line 12)
2022-07-14 15:30:34.610604
>>> shift 3'a'
'd'
2022-07-14 15:31:52.5896458
>>> shift (-3)'d'
'a'
2022-07-14 15:32:16.5625169
>>> shift 3'z'
'c'
2022-07-14 15:32:27.7652365
>>> shift 3 ' '
' '
2022-07-14 15:32:46.3579327
>>> 
2022-07-14 15:35:46.3943938
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [shift n x | x <- xs]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:35:50.3891891
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      |isLower c = int2let ((let2int c + n)`mod`26)
  14      |otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:36:23.8558956
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:37:58.5568773
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:38:40.7892521
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:11.5281095
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:48:16.6309236
>>> encode (-3) it
"haskell is fun"
2022-07-14 15:48:57.432102
>>> 
2022-07-14 16:00:10.2038379
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:00:13.8370579
>>> length tale

<interactive>:41:8: error:
    • Variable not in scope: tale :: t0 a0
    • Perhaps you meant one of these:
        ‘take’ (imported from Prelude), ‘table’ (line 20)
2022-07-14 16:00:50.8339271
>>> length table
25
2022-07-14 16:01:16.7688494
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0, 2.4, 0.2,  2.0, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:02:23.587752
>>> length table
26
2022-07-14 16:02:26.7894073
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2,  2.0, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:04:10.3895508
>>> length table
26
2022-07-14 16:04:13.5687458
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2,  2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100            
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100            
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:06:51.4891053
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2,  2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m) * 100  
  27            
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:42.699438
>>> percent 5 15
33.333336
2022-07-14 16:09:02.9409398
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char ->Int
   6  let2int  c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n)`mod`26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2,  2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = ( fromIntegral n / fromIntegral m) * 100  
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:23.3100208
>>> percent 5 15
33.333336
2022-07-14 16:14:45.5115988
>>> count 's' "Missippi"
2
2022-07-14 16:15:49.1550594
>>> :q
Leaving GHCi.
